  # Алгоритмы для работы с графикой
Этот проект включает несколько алгоритмов для построения линий и окружностей, а также пользовательский алгоритм интерполяции. Описания каждого алгоритма, их пошаговый разбор и примеры применения представлены ниже.

# Содержание
 # Руковожство пользователя 
 # Описание алгоритмов 
 ## Алгоритм ЦДА (Цифровой Дифференциальный Анализатор)
 ## Алгоритм Брезенхема для построения линий
 ## Алгоритм Брезенхема для окружности
 ## Пошаговый алгоритм интерполяции (StepByStep) 
 ## Алгоритм ЦДА
 ## Сравнительная характеристика алгоритмов 

 # Руковожство пользователя 
## Запуск:
Склонируйте файлы с помощью команды git clone ...

Откройте файл index.html в любом современном браузере (Chrome, Firefox, Edge и т.д.).

## Взаимодействие с программой
а странице будет отображен элемент канвас (полотно для рисования), а также несколько кнопок для выбора алгоритма.
Пользователи могут вводить координаты начальной и конечной точки для рисования линий и окружностей, а также задавать радиус для окружностей.
После нажатия на кнопку вы увидете время работу алгоритма и результат в рамках ваших значений
Наслаждайтесь!

## Описание
# ЦДА (Цифровой Дифференциальный Анализатор) — это простой и быстрый алгоритм для построения линии между двумя точками, вычисляющий промежуточные точки с помощью приращений.

## Пошаговый алгоритм:
Входные координаты: начальная (x0, y0) и конечная (x1, y1).
## Вычисляются разности:
dx = x1 - x0
dy = y1 - y0.
## Определяется количество шагов:
steps = max(|dx|, |dy|).
## Находятся приращения на каждом шаге:
xIncrement = dx / steps
yIncrement = dy / steps.
## Итеративно добавляются точки, начиная с (x0, y0):
x += xIncrement
y += yIncrement.
Итерации продолжаются до тех пор, пока не достигнуты координаты конечной точки.
Алгоритм Брезенхема для линий
## Описание
Алгоритм Брезенхема для построения линий используется для создания дискретных точек на линии, минимизируя ошибки округления.
Он основан на использовании целочисленной арифметики.

## Пошаговый алгоритм:
Входные координаты: начальная (x0, y0) и конечная (x1, y1).
## Рассчитываются:
dx = |x1 - x0|,
dy = |y1 - y0|.
## Выбирается шаг по оси:
Если dx > dy, линия "доминирует" по оси X.
Если dy > dx, линия "доминирует" по оси Y.
## Вычисляется начальная ошибка:
error = 2 * dy - dx (если X-доминирующая) или наоборот.
В цикле на каждом шаге:
Текущая точка добавляется в массив.
Ошибка корректируется:
Если ошибка >= 0, добавляется шаг по другой оси и обновляется ошибка.
Алгоритм Брезенхема для окружности
Описание
Алгоритм Брезенхема для окружности генерирует точки, используя свойства симметрии окружности. Это оптимальный способ для рисования окружностей в дискретной среде.

# Пошаговый алгоритм:
## Входные данные: центр окружности (xc, yc) и радиус r.
# Инициализация начальных условий:
x = 0, y = r, d = 3 - 2 * r.
Для каждого квадранта вычисляются симметричные точки.
Пока y >= x:
Генерируются точки по формуле симметрии.
Если d > 0, уменьшаем y.
Увеличиваем x и обновляем d.
Пользовательский алгоритм StepByStep
## Описание
Этот алгоритм интерполяции используется для создания равномерно расположенных точек между двумя координатами. Он позволяет гибко управлять шагами через параметр increment.

## Пошаговый алгоритм:
Входные данные: начальная точка (x0, y0), конечная (x1, y1), минимальный шаг increment.
Рассчитываются:
dx = x1 - x0,
dy = y1 - y0.
Вычисляется количество шагов:
steps = max(|dx|, |dy|).
На каждом шаге:
Приращения для каждой координаты:
dxIncrement = dx / steps,
dyIncrement = dy / steps.
Генерируются новые точки, начиная с (x0, y0), пока расстояние до конечной точки больше increment.
Добавляется конечная точка (x1, y1) в массив.
Пример вызова
## Пример вызова функции StepByStep:

```javascript
function stepByStepAlgorithm(x0, y0, x1, y1, increment) {
    let points = [];
    let dx = x1 - x0;
    let dy = y1 - y0;
    let x = x0;
    let y = y0;
    let steps = Math.max(Math.abs(dx), Math.abs(dy));
    let dxIncrement = dx / steps;
    let dyIncrement = dy / steps;

    while (Math.abs(x - x1) > increment || Math.abs(y - y1) > increment) {
        points.push([x, y]);
        x += dxIncrement;
        y += dyIncrement;
    }
    points.push([x1, y1]);
    return points;
} 

let points = stepByStepAlgorithm(0, 0, 10, 10, 0.5);
console.log(points);
```
# Сравнение методов:

# Брезенхем 
 это алгоритм, который хорошо работает в случае, когда нужно быстро и эффективно рисовать линии
 с минимальными вычислениями, но он не поддерживает сглаживание. 
 Его часто применяют в играх и простых графических приложениях.
## Плюсы:
Высокая скорость: поскольку Брезенхем использует только целочисленные вычисления, его очень легко реализовать и он быстро работает.
Минимальные ресурсы: подходит для старых и встроенных систем.
## Минусы:
Отсутствие антиалиасинга: линии выглядят «пиксельными» или «ступенчатыми», особенно при наклонных или диагональных линиях.



# ЦДА 
 более старый и менее точный, использует фракционные значения,
 что может привести к небольшим погрешностям, а также не предоставляет сглаживания.
## Плюсы:
Простота реализации.
Быстродействие для прямых линий.
## Минусы:
Меньше точности, особенно для наклонных или диагональных линий.
Отсутствие сглаживания.



# Метод Ву 
 предпочтителен для случаев, где важна высокая визуальная точность и сглаживание.
 Он применим в высококачественных графических приложениях и на современных платформах, 
 таких как игровые движки, 2D-графика и векторные графики.
## Плюсы:
Высокое качество отображения линий.
Поддержка антиалиасинга: помогает избавиться от ступенчатости на диагональных линиях.
## Минусы:
Производительность: Из-за фракционных вычислений алгоритм может быть медленнее по сравнению с другими методами, особенно на устройствах с ограниченными ресурсами.

